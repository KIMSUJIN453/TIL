# 문자열
## 조회/탐색 및 검증
### 1. s.find(x)
x의 첫 번째 위치를 반환  
x가 없으면 -1을 반환  
```
print('banana'.find('a'))  # 1
print('banana'.find('z'))  # -1
```

### 2. s.index(x)
x의 첫 번째 위치를 반환  
find와 달리 없으면 **오류 발생**  
```
print('banana'.index('a'))  # 1
print('banana'.index('z'))  # ValueErrir 어쩌구
```

### 3. s.isupper(x) / s.islower(x)
문자열이 **모두** 대문자 / 소문자로 이루어져 있는지 확인  
```
string1 = 'HELLO'
string2 = 'Hello'
string3 = 'hello'

print(string1.isupper())  # True
print(string2.isupper())  # False
print(string3.isupper())  # False

print(string1.islower())  # False
print(string2.islower())  # False
print(string3.islower())  # True
```

### 4. s.isalpha(x)
문자열이 알파벳으로만 이루어져 있는지 확인  
```
stirng1 = 'Hello'
string2 = 'Hello123'
print(string1.isalpha())  # True
print(stirng2.isalpha())  # False
```

## 조작 (새로운 문자열 반환)
문자열은 불변으로 원본을 바꾸지 못 한다.  
따라서 새로운 문자열을 반환한다.  
### 1. s.replace(old, new[,count])
바꿀 대상 글자를 새로운 글자로 바꿔서 반환  
[,count] 는 선택 인자로 바꿀 갯수를 넣을 수 있다.  
```
text = 'Hello, world! world world'
new_text1 = text.replace('world', 'Python')
new_text2 = text.replace('world', 'Python', 1)
print(new_text1)   # Hello, Python! Python Python
print(new_text2)   # Hello, Python! world world
```

### 2. s.strip([chars])
문자열의 시작과 끝에 있는 공백 혹은 지정 문자를 제거  
[chars]에 제거할 문자 지정  
단, [chars]가 양 끝이어야 제거된다. 가운데에 있으면 제거되지 않는다.
```
text = '   Hello, world!    '
new_text1 = text.strip()
print(new_text1)  # 'Hello, world!'

some_text = 'Hello, world!'
new_text2 = some_text.strip('H')
print(new_text2)
```

### 3. s.split(sep=None, maxsplit=-1)
sep을 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환  
인자들이 기본 값이라 안 넣어도 됨  
sep을 안 넣으면 공백을 기준으로 나눔  
sep을 넣으면 그 문자를 기준으로 나눔
maxsplit 숫자만큼 분할을 수행함  
```
text = 'Hello, world!'
words1 = text.split(',')
words2 = text.split()
print(words1)   # ['Hello', ' world!']
print(words2)   # ['Hello,', 'world!']
```

### 4. 'separator'.join(iterable)
많이 쓰이는 메서드  
iterable의 문자열을 연결한 문자열을 반환  
요소를 구분자로 연결해서 묶는다.  
```
words = ['Helo', 'world!']
text = '-'.join(words)
print(text)    # 'Hello-world!'
```

### 5. 대소문자 변경
```
text = 'heLLo, woRld!'

new_text1 = text.capitalize()
print(new_text1)  # Hello, world!

new_text2 = text.title()
print(new_text2)  # Hello, World!

new_text3 = text.upper()
print(new_text3)  # HELLO, WORLD!

new_text4 = text.lower()
print(new_text4)  # hello, world!

new_text5 = text.swapcase()
print(new_text5)  # HEllo, WOrLD!
```

# 리스트
리스트 메서드를 가장 많이 사용하게 될 것임  
리스트는 가변객체이기 때문에 문자열과 달리 원본을 조작한다.  
원본을 조작하기 때문엔 **반환 값이 없다.** (일부 제외)  
## 리스트 값 추가 및 삭제
### 1. l.append(X)
가장 많이 쓰게 될 메서드, 알고리즘 문제에서도 많이 나옴  
원본의 마지막 위치에 값을 추가하고, None을 반환  
값을 여러 개 넣을 수 없다.  
여러 개 넣는 경우 하나로 묶여서 추가된다.  
```
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)    # [1, 2, 3, 4]
print(my_list.append(5))   # None

your_list = [5, 6]
my_list.append(your_list)
print(my_list)   # [1, 2, 3, 4, [5, 6]]
```

### 2. l.extend(iterable)
리스트에 다른 반복 가능한 객체의 모든 항목을 추가
```
my_list = [1, 2, 3]
my_list.extend([4, 5, 6])
print(my_list)   # [1, 2, 3, 4, 5, 6]
my_list.extend(100)  # TypeError 반복 가능 객체가 아니면 추가 불가
```

### 3. l.insert(i, x)
리스트의 지정한 인덱스 i 위치에 항목 x를 삽입
```
my_list = [1, 2, 3]
my_list.insert(1,5)
print(my_list)   # [1, 5, 2, 3]
```

### 4. l.remove(X)
리스트에서 첫 번째로 일치하는 항목(x)을 삭제
```
my_list = [1, 2, 2, 3, 3, 3, 2]
my_list.remove(2)
print(my_list)  # [1, 2, 3, 3, 3, 2]
```

### 5. l.pop(i)
append와 함께 아주 중요!!!
리스트에서 지정한 인덱스(i)의 항목을 제거하고 **반환**  
지정 인덱스를 작성하지 않을 경우 **마지막 항목을 제거**
```
my_list = [1, 2, 3, 4, 5]
item1 = my_list.pop()
item2 = my_list.pop(0)
print(item1)  # 5
print(item2)  # 1
print(my_list)  # [2, 3, 4]
```

### 6. l.clear()
리스트의 모든 항목을 삭제  
리스트라는 변수를 제거하는 게 아니라 안의 요소를 제거하는 것  
```
my_list = [1, 2, 3]
my_list.clear()
print(my_list)   # []
```

## 탐색 및 정렬
### 1. l.index(x)
리스트에서 첫 번째로 일치하는 항목 x의 **인덱스를 반환**  
```
my_list = [1, 2, 3]
index = my_list.index(2)
print(index)  # 1
```

### 2. l.coun(x)
리스트에서 항목 x의 **개수를 반환**
```
my_list = [1, 2, 2, 3, 3, 3]
count = my_list.count(3)
print(count)  # 3
```

### 3. l.reverse()
리스트의 순서를 역순으로 변경 (**정렬 아님**)  
원본을 변경할 뿐, 반환 값이 없기 때문에 None이 나옴
```
my_list = [1, 2, 3, 4]
my_list.reverse()
print(my_list)   # [4, 3, 2, 1]
print(my_list.reverse())  # None
```

### 4. l.sort()
원본 리스트를 오름차순으로 정렬  
내림차순으로 하고 싶을 때는 인자로 reverse=True를 넣어줘야 함  
원본을 바꾸기 때문에 sort 자체를 print하면 None을 반환함  
```
my_list = [2, 3, 5, 4, 1]
my_list.sort()
print(my_list)  # [1, 2, 3, 4, 5]
print(my_list.sort())  # None

your_list = [10, 30, 50, 40, 20]
your_list.sort(reverse=True)
print(your_list)   # [50, 40, 30, 30, 20, 10]
```
# 딕셔너리 (dict)
### 1. d.get(key[,default])
키에 연결된 값을 반환한다.  
키가 없으면 None 혹은 기본 값을 반환한다.  
[,default]는 선택 인자로 기본 값을 설정할 수 있다.  
키가 없어도 다른 값을 반환해야 하면 get을 써야 하고,  
키가 없을 때 오류가 나야 한다면 기본과 같이 대괄호([])를 사용한다.   
```
person = {'name': 'Alice', 'age': 25}
print(person.get('name'))      # Alice
print(person.get('country'))   # None
print(person.get('country', '해당 키는 존재하지 않습니다.'))  # 해당 키는 존재하지 않습니다.
# print(person['country'])   # KeyError: 'country'
```
  
### 2. d.keys()
딕셔너리 키를 모은 객체를 반환한다.  
해당 객체를 for 문을 활용하여 순회할 수 있다.  
dict_keys(['name', 'age'])는 실시간으로 동기화되는 확인 창(view)이라고 비유할 수 있다.  
dict_keys는 시퀀스가 아니므로 인덱스로 접근할 수 없다.  
```
person = {'name': 'Alice', 'age': 25}
print(person.keys())     # dict_keys(['name', 'age'])
for item in person.keys():
    print(item)          # name
                         # age
```

### 3. d.values()
딕셔너리 값을 모은 객체를 반환한다.  
keys와 같이 값 모은 객체를 순회할 수 있다.  
```
person = {'name': 'Alice', 'age': 25}
print(person.values())    # dict_values(['Alice', 25])
for item in person.values():
    print(item)           # Alice
                          # age
```
  
### 4. d.items()
딕셔너리 키/값 쌍을 모은 객체를 반환한다.  
반복문 안에서 순회할 수 있다.  
```
person = {'name': 'Alice', 'age': 25}
print(person.items())      # dict_items([('name', 'Alice'), ('age', 25)])
for key, value in person.items():
    print(key, value)      # name Alice
                           # age 25
```

### 5. d.pop(key,[,default])
키를 제거하고 연결됐던 값을 반환한다.  
[,defalut] 선택 인자, key가 없으면 반환한다.  
키가 없는데 [,default]도 설정 안되어있다면 에러가 난다.  
```
person = {'name': 'Alice', 'age': 25}

print(person.pop('age'))   # 25
print(person)              # {'name': 'Alice'}
print(person.pop('country', None))    # None
print(person.pop('country'))          # KeyError
```

### 6. d.clrear()
딕셔너리의 모든 키 / 값 쌍을 제거  
```
# 똑같은 딕셔너리 유지
D1 = {'name': 'Alice', 'age': 25}
D1.clear()

# 재할당 (다른 딕셔너리가 된 것)
D2 = {'name': 'Alice', 'age': 25}
D2 = {}
```

### 7. d.setdefault(key,[,default])
키와 연결된 값을 반환한다.  
키가 없다면 [,default]와 연결한 키를 딕셔너리에 추가하고, default를 반환한다.  
(get 기능 + 추가)  
```
person = {'name': 'Alice', 'age': 25}

print(person.setdefault('country', 'KOREA'))  # KOREA
print(person,setdefault('name', 'KOREA'))   # Alice
# name 키가 있기 때문에 해당 키에 대한 값을 반환하지 default 위치에 넣어준 걸 반환하지 않는다.
print(person)    # {'name': 'Alice', 'age': 25, 'country': 'KOREA'}
```

### 8. d.update([other])
other가 제공하는 키/값 쌍으로 딕셔너리를 갱신하고 기존 키는 덮어쓴다(키가 똑같으면).  
```
person = {'name': 'Alice', 'age': 25}
other_person = 'name': 'Jane', 'country': 'KOREA'

person.update(otehr_person)
print(person)  # {'name': 'Jane', 'age': 25, 'country': 'KOREA'}

person.update(age=100, address='SEOUL')
print(person)  # {'name': 'Jane', 'age': 100, 'country': 'KOREA', 'address': 'SEOUL'}
```

# 세트 (set)
## 기본 메서드
### 1. s.add(x)
세트에 x를 추가한다.  
```
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.add('d')
print(my_set)      # {1, 2, 3, 'c', 'd', 'b', 'a'}
# set는 순서가 없기 때문에 결과는 항상 순서 무작위로 나온다.

my_set.add('d')
print(my_set)      # {1, 2, 3, 'c', 'd', 'b', 'a'}
# set는 중복 요소를 갖지 않으므로 똑같은 값을 추가하면 추가되지 않는다.
```
  
### 2. s.update(iterable)
세트에 다른 iterable 요소를 추가한다.  
```
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.update([1, 4, 5])
print(my_set)    # {'c', 2, 3, 1, 'b', 4, 5, 'a'}
```
  
### 3. s.clear()
세트의 모든 항목을 제거한다.  
```
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.clear()
print(my_set)   # ser()
```

### 4. s.remoeve(x)
세트에서 항목 x를 제거한다.  
x가 없을 경우 KeyError가 난다.  
```
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.remove(2)
print(my_set)   # {'b', 1, 3, 'c', 'a'}

my_set.remove(10)    # KeyError
```

### 5. s.pop()
세트에서 임의의 요소를 제거하고 반환한다.  
랜덤은 아니다.  
```
my_set = {'a', 'b', 'c', 1, 2, 3}

element = my_set.pop()
print(element)   # 1
print(my_set)    # {2, 3, 'b', 'a', 'c'}
```

### 6. s.discard(x)
세트에서 항목 x를 제거한다.  
remove와 달리 에러 없다.  
```
my_set = {'a', 'b', 'c', 1, 2, 3}

my_set.discard(2)
print(my_set)  # {1, 3, 'a', 'c', 'b'}
my_set.discard(10)    # Error 안 뜸
```
## 집합 메서드
### 1. 차집합
set1에는 들어있지만 set2에는 없는 항목으로 세트를 생성 후 반환한다.  
```
set1 = {0, 1, 2, 3, 4}
set2 = {1, 3, 5, 7, 9}

print(set1 - set2)
print(set1.difference(set2))
# {0, 2, 4}
```
  
### 2. 교집합
set1과 set2 모두 들어있는 항목으로 세트를 생성 후 반환한다.  
```
set1 = {0, 1, 2, 3, 4}
set2 = {1, 3, 5, 7, 9}

print(set1 & set2)
print(set1.intersection(set2))
```

### 3. 부분집합
set1의 항목이 모두 set2에 들어있으면 True를 반환한다.  
```
set1 = {0, 1, 2, 3, 4}
set2 = {1, 3, 5, 7, 9}

print(set1 <= set2)
print(set1.issubset(set2))
```

### 4. 상위집합
set1이 set2의 항목을 모두 포함하면 True를 반환한다.  
```
set1 = {0, 1, 2, 3, 4}
set2 = {1, 3, 5, 7, 9}

print(set1 >= set2)
print(set1.issuperset(set2))
```
  
### 5. 합집합
set1 또는 set2에(혹은 둘 다) 들어있는 항목으로 세트를 생성 후 반환한다.  
```
set1 = {0, 1, 2, 3, 4}
set2 = {1, 3, 5, 7, 9}

print(set1 | set2)
print(set1.union(set2))
```