# 코드 사용 모음
내가 사용해보며 기억하고 싶은 내용들 모음  

---

- 리스트 안에 딕셔너리와 리스트가 매우 많이 중첩되어있을 때  
```
name = many_list_dict[0]['school'][5]['name']
# 이런 식으로 순서 하나씩 차근차근 짚으며 찾아내기
# 리스트 영역은 인덱스로 원하는 위치로 이동하고, 딕셔너리 부분은 원하는 key를 넣어주기
```
  
- 딕셔너리 반복 돌릴 때
```
for key, value in dict_name.items():
    print(f'{key} : {value}')

# 이렇게 작성하면 key : value 이런 형식으로 출력됨
```
  
- 함수 여러 개이고, 한 함수에서 다른 함수를 사용할 때
```
def B(b):
    one = B[1]
    print('이것은 {one}이다.')

def A(a):
    some = a[0]
    B(some)

# 안에 내장 함수로 사용할 함수를 먼저 정의해줘야 한다.
```
  
- 리스트 컴프리헨션
```
'표현식' for '변수' in '반복가능한 자료형

squeares = [x**2 for x in range(5)]
print(squeares)     # [0, 1, 4, 9, 16]

data = [1, 2, 3, 4, 5]
target = [2, 4]

result = [x for x in data if x not in target]
print(result)    # [1, 3, 5]
```

- 값이 길 때 보기 좋게 여러 줄로 줄바꿈해서 보고 싶을 때
```
from pprint import pprint

my_dict = {'name': 'Alice', 'age': 30, 'city': 'Secoul'}

pprint(my_dict)

# 출력
"""
{
    'name': 'Alice',
    'age': 30,
    'city': 'Seoul'
}
"""
```
  
- 리스트 순회할 때, 2차원 리스트 인덱스로 접근하기
```
for i in range(len(my_list))
```
  
- 딕셔너리 한 개의 키에 여러 개의 값을 리스트로 추가할 때
```
if 'fruits' not in my_dict:
    my_dict['fruits'] = []   # my_dict의 'fruits' 키의 값으로 빈 리스트 생성

    my_dict['fruits'].append('apple')     # 빈 리스트에 값 추가
    my_dict['fruits'].append('banana')
```

- for 문 돌 때 list와 print의 위치
```
for i in rage(len(some_data)):
    my_list = []
    if i <= 9:
        name = some_data[i]['name']
        my_list.append(name)

print(my_list)   #some_data의 마지막 순서의 이름만 출력됨

# 빈 리스트가 for 구문 안에 있으면 반복이 돌면서 해당 리스트가 계속 비워지게 됨
# 그에 따라 마지막에 남는 요소만 프린트됨

my_list = []

for i in rage(len(some_data)):
    if i <= 9:
        name = some_data[i]['name']
        my_list.append(name)

print(my_list) # some_data 의 모든 순서 이름이 출력됨

# 빈 리스트가 global 영역에 있어서 for 구문이 반복되며 이름이 계속 추가됨
```

- 딕셔너리 get 과 setdefault 메서드
    - 딕셔너리에 없는 키와 값을 출력하고 싶을 때는 get으로 가능하지만  
    - 딕셔너리에 없는 키와 값을 추가하고 싶을 때는 setdefault를 써서 추가해야 한다.  
```
my_dict.get(var, '변수로도 키 설정 가능')
#'변수로도 키 설정 가능'이 반환되지만 딕셔너리에 추가되진 않는다.

print(my_dict)                                 # 기존 딕셔너리 값만 출력
print(my_dict.get(var, '변수로도 키 설정 가능'))  # '변수로도 키 설정 가능' 만 출력


my_dict.setdefault(var, '변수로도 키 설정 가능')
#'var'와 '변수로도 키 설정 가능'이 딕셔너리에 추가된다.

print(my_dict.setdefault(var, '변수로도 키 설정 가능'))   # '변수로도 키 설정 가능' 만 출력
print(my_dict)                                         # my_dict에 추가된 내용까지 함께 출력
```
  
- 여러 세트를 인자로 받은 후 합집합으로 합한 세트를 반환하고 싶을 때  
```
def union_multiple_sets(*sets):
    multiple_sets = set()          # 합한 세트를 일단 빈 세트로 만든다.
    if len(sets) >= 2:             # sets의 요소가 2개 이상인 경우
        for s in sets:             # sets의 set를 꺼내서 합집합 해준다.
            multiple_sets = multiple_sets.union(s)
            # multiple_sets.union(s) 만 적으면 빈 세트로 함수가 끝난다.
```
  
- 값이 특정 타입인지 확인할 때  
```
isinstance('확인받을것', '확인받고 싶은 유형')

# 예시
A = []
B = {}
isinstance(A, list)
isinstance(B, dict)
```
  
- 재귀로 모든 키를 꺼내는 함수  
```
def get_all_keys_from_dict(dictionary):
    keys_list = []
    if isinstance(dictionary, dict):
        for key, value in dictionary.items():
            keys_list.append(key)   # 현재 키 추가
            keys_list.extend(get_all_keys_from_dict(value))  # 하위 딕셔너리 재귀 탐색
    
    return keys_list
```
  
- 내장 함수 없이 최소값, 최대값 구하기  
```
def find_min(list):
    min_value = list[0]

    for num in list:
        if num < min_value:
            min_value = num
        
    return min_value

def find_max(list):
    max_value = list[0]

    for num in list:
        if num > max_value:
            max_value = num
    
    return max_value
```
  
- 재귀함수  
```
def factorial(n):
    if n == 0:          # 종료 조건
        return 1
    else:
        return n * factorial(n-1)   # 재귀 호출: n과 n-1의 팩토리얼을 곱한 결과 반환

print(factorial(9))
```
  
- 클래스 변수 접근할 때  
```
class Car:
    number_of_car = 0

    def __init__(self, name):
        self.name = name
        number_of_car += 1          # 이렇게 작성하면 오류남
        Car.number_of_car += 1      # 이렇게 클래스 이름을 같이 명시해줘야 함
```
  
- 인스턴스 이름(변수) 불러오고 싶을 때  
```
class Student:
    def __init__(self, name):
        self.name = name

student1 = Student('홍길동')
print(student1)                # 이렇게 하면 오류남
print(student1.name)           # 이렇게 인스턴스 이름과 같이 써줘야함
```
  
- 음수와 양수 0 예외처리  
```
def number_check():
    try:
        number = int(input('숫자 입력: '))
        if number < 0:
            print('음수')
            number_check     # 이걸 넣어주면 다음 숫자 입력으로 이어짐
        elif number > 0:
            print('양수')
            number_check
        elif number == 0:
            print('0')
            number_check
    except Exception:       # 가장 큰 에러 유형(?)을 넣어서 모든 예외사항 처리함
        print('잘못된 입력')
```
  
- super().__init__ 사용할 때  
```
class Family:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Mom(Fammily):
    def __init__(self, name, age, job):
        super().__init__(name, age)        # 이런 식으로 넣어줘야 함
```
