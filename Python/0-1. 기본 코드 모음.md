# 기본 코드 모음
내가 참고하려고 만든 기본 코드 모음

## 기본
1. **변수 재할당**
```
number = 10
double = 2 * number
print(double) #20

number = 5
print(double) #20

 # number 변수가 가리키는 '대상'이 바뀐 것이지 변수 double은 여전히 값 20을 참조하는 것은 변함 없다.  
```

2. **숫자형 데이터**
```
int(3)       #정수 자료형
float(3.14)  #실수 자료형

#지수 표현법, 'e' 또는 'E'를 사용
#1,230,000,000 (1.23 * 10^9)
big_number = 1.23e9

#0.00314 (3.14 * 10^_3)
small_number = 3.14e-3

-2 ** 4     # -16
-(2 **4)    # -16
(-2) ** 4   # 16
```
  
3. **문자열**
```
my_str = 'Hello'
my_str[1] # e
my_str[1:4] # ell
my_str[:3]  # Hel
my_str[3:]  # lo
my_str[::2] # hlo
my_str[::-1] # olleh
len(my_str)  # 5
for char in my_str   # H, e, l, l, o

multi_line_str = """
여러 줄로
이루어진
문자열
"""

f-string
name = '홍길동'
age = 30
introduce = f'저는 {name}이고 나이는 {age}살 입니다.'
print(introduce)
#저는 홍길동이고 나이는 30살입니다.

#문자열 바꾸기
my_str = 'Hello'

new_str = my_str[0] + 'a' + my_str[2:]

print(new_str) #Hallo
```
  
4. **list**
```
my_list = [1, 2, 3, 'apple', ['banana', 'c']]

print(len(my_list)) # 5
print(my_list[4][1]) # c
print(my_list[-1][0][2]) # n

my_list[4] = 'b'
print(my_list) # [1, 2, 3, 'apple', 'b']

my_list[2:4] = ['ㄱ', 'ㄴ', 'ㄷ']
print(my_list)  # [1, 2, 'ㄱ', 'ㄴ', 'ㄷ', 'b']
```

5. **tuple**
```
my_tuple_1 = ()
my_tuple_2 = (1,)
my_tuple_3 = (1, 2, 3, 'apple')

print(my_tuple_3[0]) # 1
print(my_tuple_3[1:3]) # 2, 3
print(len(my_tuple_3))  # 5

my_tuple_3[1] = 4    #TypeError
```

6. **range**
```
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

print(my_range_2) # range(1, 10)

print(list(my_range_1)) # [0, 1, 2, 3, 4]
print(list(my_range_2)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(my_range_3)) # [5, 4, 3, 2, 1]

print(list(range(1, 5)))  # [1, 2, 3, 4]
print(list(range(5, 1)))  # []
print(list(range(5, 1, -1)))  # [5, 4, 3, 2]
print(list(range(1, 5, -1)))  # []
```
  
7. **dict**
```
my_dict = {'name': '홍길동', 'age': 30}

print(my_dict)  # {'name': '홍길동', 'age': 30}
print(my_dict['name']) #'홍길동'
print(my_dict['test']) #KeyError : 'test'

# 추가
my_dict['address'] = '서울'
print(my_dict) #{'name': '홍길동', 'age': 30, 'address': '서울'}

# 변경
my_dict['age'] = 28
print(my_dict) = {'name': '홍길동', 'age': 28}
```
8. **set**
```
my_set_0 = set()
my_set_1 = {1, 2, 3}
my_set_2 = {3, 4, 5}
my_set_3 = {1, 1, 1}

print(my_set_0) # set()
print(my_set_1) # {1, 2, 3}
print(my_set_3) # {1}

#합집합
print(my_set_1 | my_set_2) # {1, 2, 3, 4, 5}

#차집합
print(my_set_1 - my_set_2) # {1, 2}

#교집합
print(my_set_1 & my_set_2) #{3}
```

9. **is와 ==** 
```
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b) # True (두 리스트의 값은 동일)
print(a is b) #False (서로 다른 리스트 객체)

b = a   # b가 a를 그대로 참조하도록 할 경우
print(a is b)  # True (같은 객체를 가리키므로 True)

my_list = [1, 2, 3]
new_list = my_list

new_list[0] = 100
print(my_list)   # [100, 2, 3]

my_list[1] = 200
print(new_list)  # [100, 200, 3]

print(my_lisst is new_list)  #True

a_list = [1, 2, 3]
b_list = a_list [:]  # 별도의 새로운 리스트를 준 것

a_list[0]
print(b_list[0])  #1

a_list = [
    [1, 2],
    [3, 4],
]
b_list = a_list[:]

a_list[0] = [5, 6]
a_list[1][0] = 7

print(b_list[0]) # 1, 2
print(b_list[1][0]) # 7

#b_list는 a_list의 값을 복사해서 다른 주소에 할당했는데,
a_list안에 있는 list의 주소는 b_list 안에 있는 list의 주소와 동일함
그래서 안의 것을 바꿨을 때는 바뀜

#안의 것까지 싹 다 새로 만들 때
import copy
backup_original = copy.deepcopy(original)
```
10. **논리 연산자**
```
# and : 모두 True인 경우에만 전체 표현식을 True로 평가
# or : 하나라도 True인 경우 전체 표현식을 True로 평가
# not : 단일 피연산자를 부정

print(True and False) # False
pirnt(True or False)  # True
print(not True)  # False

num = 15
result = (num > 10) and (num % 2 == 0)
print(result)  # False

name = 'Alice'
age = 25
result = (name == 'Alice') or (age == 30)
print(result)  #True
```
### 함수
```
def greet(name, age=30):
    print(f'안녕하세요, {name}님! {age}살이시군요.')

greet('Alice')  # 안녕하세요, Alice님! 30살이시군요.
greet('Alice', 25)  #안녕하세요, Alice님! 25살이시군요.
greet(25, 'Alice')  #안녕하세요, 25님! Alice살이시군요.
greet(name= 'Alice', age= 25)  #안녕하세요, Alice님! 25살이시군요.

def calculate_sum(*args):
    print(args)

claculate_sum(1, 100, 30)    # (1, 100, 30)

def print_info(**kwargs):
    print(kwargs)

print_info(name= 'Eve', age= 30)  # {'name': 'Eve', 'age': 30}

def get_user_info():
    name = 'Alice'
    age = 30
    return name, age

user_data = get_user_info()
print(user_data)   # ('Alice', 30)

# 콤마로 여러 값을 반환한 것처럼 보이지만 하나의 튜플로 패킹하여 반환한다.
# 함수의 반환 값은 언제나 단 하나의 값(객체)만 반환할 수 있다.
```
1.  **재귀 함수**
```
#함수 내부에서 자기 자신을 호출하는 함수로,
언제 재귀 함수를 끝낼 것인지 설정해줘야 함

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))
```

2. **내장 함수**
```
#파이썬이 기본적으로 제공하는 함수
numbers = [1, 2, 3, 4, 5]

print(len(numbers))  # 5
print(max(numbers))  # 5
print(min(numbers))  # 1
print(sum(numbers))  # 15
print(sorted(numbers, reverse=True)) # [5, 4, 3, 2, 1]
```
3. **LEGB Rule**
```
x = 'G'
y = 'G'

def outer_func():
    x = 'E'
    y = 'E'

    def inner_func(y):
        z = 'L'
        print(x, y, z)  # E P L
        return(y,z)
    
    inner_func('P')
    print(x, y)   # E E
    return(x, y)

outer func()
print(x, y)  # G G

#inner_func('P')을 넣고 반환되는 값은 (P, L)인 튜플이지 'y = P, z = L'이라는 변수 할당이 아니기 때문에ㅡ
맨 마지막 줄의 print(x, y)는 G G 이다.

num = 0

def increment():
    global num    # num을 전역 변수로 선언
    num += 1

print(num)    # 0
increment()
print(num)    # 1
```
4. **패킹, 언패킹**
```
def my_function(x, y, z):
    print(x, y, z)

names = ['alice', 'jane', 'peter']
my_function(*names)    # alice jane peter

my_dict = {'x': 1, 'y': 2, 'z': 3}
my_function(**my_dict)   # 1 2 3
```
5. **map 함수**
```
map(fucntion, iterable)
#iterable의 요소가 1개씩 function에 들어가 결과가 쌓인다.

numbers = [1, 2, 3]
result = map(str, numbers)

print(result)  # <map object 어쩌구저쩌구>
print(list(result))  # ['1', '2', '3']
#전체 값을 확인하려면 list나 tuple로 형변환을 해주거나 반복을 돌려야 한다.
```
6. **lambda 표현식**
```
def addition(x, y):
    return x + y

result = addition(3, 5)
print(result)   # 8

# lambda 사용하면
addition = lambda x, y: x + y

result = addition(3, 5)
print(result)   # 8

#람다 표현식 활용
numbers = [1, 2, 3, 4, 5]

# lambda 미사용
def square(x):
    return x**2

squared1 = list(map(square, numbers))
print(squeared1)   # [1, 4, 9, 16, 25]


# lambda 사용
squared2 = list(map(lambda x: x**2, numbers))
print(squeared2)   # [1, 4, 9, 16, 25]
```
7. **zip 함수**
```
girls = ['jane', 'ashley']
boys = ['peter', 'jay']
pair = zip(girsl, boys)

print(pair)  # <zip object 어쩌구저쩌구>
print(list(pair))  # [('jane', 'peter'), ('ashley', 'jay')]
```

### 라이브러리
라이브러리 > 패키지 > 모듈
- 연관 모듈들을 하나의 디렉토리에 모아놓은 것 = 패키지
- 
```
#내장 모듈 가져올 때
import math

print(math.pi)       #모듈명.변수명
print(math.sqrt(4))  #모듈명.함수명

#from 절 사용해서 가져올 때

from math import pi, sqrt

print(pi)        #변수명
print(sqrt(4))   #함수명

# 별칭 부여(as)
import pandas as pd
import matplotlib.pyplot as plt

plt.plot(x, y)
#긴 함수나 변수명에 별칭 부여해서 간단하게 사용

#사용자 정의 모듈(직접 정의한 모듈 사용)

# my_math.py 생성하여 두 수의 합을 구하는 add 함수 작성
def add(x,y):
    return x + y

# 같은 위치에 sample.py 파일을 생성하고 my_math 모듈의 add 함수 import 후 add 함수 호출
import my_math

print(my_math.add(10, 20)) # 30

# 외부 패키지 설치하여 사용할 때
# requests 패키지 예시
pip install requests # 설치할 파일 위치에서 터미널에 입력

import requests

url = '내가 요청할 url'
response = requests.get(url).json()
print(response)

# .get(url) 주어진 url로 요청하는 requests 패키지 메서드
# .json() 문자열로 이루어진 json 자료형을 dict 자료형으로 변환시키는 requests 패키지 메서드
```

### 제어문
1. **조건문**
```
temp = int(input())  # input 받는 것은 문자열로 저장되기 때문에 정수형으로 변경

if temp > 30:            # 만약 입력이 30을 초과하면
    print('so hot')      

elif temp > 25:          # 아래는 실행되지 않는다.
    print('hot')

else:
    print('soso')

---
if temp > 30:            # 만약 입력이 30을 초과해도
    print('so hot')

if tmep >25:             # 실행된다. (위의 if와 별개의 if 문으로 인식)
    print('hot')

else:
    print('soso')

---
if temp > 30:
    print('so hot')

    print('bye')         # if가 True일 때 같이 실행됨, 들여쓰기 유의

print('good bye')        # if 문이 종료되면 출력됨

#중첩 조건문
temp = 36   # 출력: so hot
            #      dangerous

if temp > 30:            
    print('so hot')

    if temp > 35:
        print('dangerous')     

elif temp > 25:          
    print('hot')

else:
    print('soso')
```
2. **반복문**
- for 문
```
item_list = ['apple', 'banana', 'coconut']

for item in itme_list:   # item : 반복 변수
    print(item)

# 출력
"""
apple
banana
coconut
"""

country = 'Korea'

for char in country:
    print(char)

# 출력
"""
K
o
r
e
a
"""

for i in range(5):
    print(i)

# 출력
"""
0
1
2
3
4
"""

my_dict = {
    'x': 10,
    'y': 20,
    'z': 30,
}

for key in my_dict:
    print(key)
    print(my_dict[key])

# 출력
"""
x
10 
y
20
z
30
"""
# 딕셔너리 반복의 임시변수는 key다.
# value를 출력하려면 print(my_dict)로 해야 한다.

numbers = [4, 6, 10, -8, 5]

for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2

print(numbers)     # [8, 12, 20, -16, 10]

outers = ['A', 'B']
inners = ['c', 'd']

for outer in outers:
    for inner in inners:
        print(outer, inner)

# 출력
(A, c)
(A, d)
(B, c)
(B, d)

# 중첩되었을 때 바깥 반복문의 한 번 돌 때, 안 반복문이 다 돌아야 한다.
# 안 반복문이 다 돌고난 후 바깥 반복문의 다음 번 순서가 돌아간다.

elements = [['A', 'B'], ['c', 'd']]

for elem in elemnets:
    for item in elem:
        print(item)

#출력
"""
A
B
C
D
"""
```
- while 문 : 반드시 종료 조건 필요
```
while a < 3:
    print(a)
    a += 1

print('end')

# 출력
"""
0
1
2
끝
"""

account = 100

if account > 0:       #결과가 참일 때 진행
    account -= 50

while account > 0:    #결과가 참인 동안 진행
     account -= 50    #언젠가 조건이 False가 되게끔 만들어야 함

#위 코드에서 구조적으로는 if와 while은 같은 결과가 나오긴함

account = 100

while account > 0:
    account += account * 0.035   #위험!! 전역변수 값에 따라 무한 반복됨
    account -= 50

#만약 account가 10000이었다면 무한반복이 되었을 것임.
#350 증가하는데 50씩만 감소하기때문에
```
- 반복 제어
```
for i in range(10):
    if i == 5:
        break     # break 만나면 남은 코드 무시하고 반복 즉시 종료
    print(i)      # 0 1 2 3 4

    if i % 2 == 0:
        continue  # continue 만나면 다음 코드는 무시하고 다음 반복을 수행
    print(i)      # 1 3 5 7 9

while True:
    if condition1:
        break
    elif condition2:
        pass         # 빈 코드를 의미
    else:
        print('출력')

# for-else 예시
registered_ids = ['user1', 'user2', 'user3']
id_to_check = 'user1'

for existing_id in registered_ids:
    if existing_id == id_to_check:
        print('이미 사용 중인 아이디입니다.')
        break
else:     #for 루프가 break로 중단되면 실행됨
    print('사용 가능한 아이디입니다.')

```
