### 함수
```
def greet(name, age=30):
    print(f'안녕하세요, {name}님! {age}살이시군요.')

greet('Alice')  # 안녕하세요, Alice님! 30살이시군요.
greet('Alice', 25)  #안녕하세요, Alice님! 25살이시군요.
greet(25, 'Alice')  #안녕하세요, 25님! Alice살이시군요.
greet(name= 'Alice', age= 25)  #안녕하세요, Alice님! 25살이시군요.

def calculate_sum(*args):
    print(args)

claculate_sum(1, 100, 30)    # (1, 100, 30)

def print_info(**kwargs):
    print(kwargs)

print_info(name= 'Eve', age= 30)  # {'name': 'Eve', 'age': 30}

def get_user_info():
    name = 'Alice'
    age = 30
    return name, age

user_data = get_user_info()
print(user_data)   # ('Alice', 30)

# 콤마로 여러 값을 반환한 것처럼 보이지만 하나의 튜플로 패킹하여 반환한다.
# 함수의 반환 값은 언제나 단 하나의 값(객체)만 반환할 수 있다.
```
1.  **재귀 함수**
```
#함수 내부에서 자기 자신을 호출하는 함수로,
언제 재귀 함수를 끝낼 것인지 설정해줘야 함

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

print(factorial(5))
```

2. **내장 함수**
```
#파이썬이 기본적으로 제공하는 함수
numbers = [1, 2, 3, 4, 5]

print(len(numbers))  # 5
print(max(numbers))  # 5
print(min(numbers))  # 1
print(sum(numbers))  # 15
print(sorted(numbers, reverse=True)) # [5, 4, 3, 2, 1]
```
3. **LEGB Rule**
```
x = 'G'
y = 'G'

def outer_func():
    x = 'E'
    y = 'E'

    def inner_func(y):
        z = 'L'
        print(x, y, z)  # E P L
        return(y,z)
    
    inner_func('P')
    print(x, y)   # E E
    return(x, y)

outer func()
print(x, y)  # G G

#inner_func('P')을 넣고 반환되는 값은 (P, L)인 튜플이지 'y = P, z = L'이라는 변수 할당이 아니기 때문에ㅡ
맨 마지막 줄의 print(x, y)는 G G 이다.

num = 0

def increment():
    global num    # num을 전역 변수로 선언
    num += 1

print(num)    # 0
increment()
print(num)    # 1
```
4. **패킹, 언패킹**
```
def my_function(x, y, z):
    print(x, y, z)

names = ['alice', 'jane', 'peter']
my_function(*names)    # alice jane peter

my_dict = {'x': 1, 'y': 2, 'z': 3}
my_function(**my_dict)   # 1 2 3
```
5. **map 함수**
```
map(fucntion, iterable)
#iterable의 요소가 1개씩 function에 들어가 결과가 쌓인다.

numbers = [1, 2, 3]
result = map(str, numbers)

print(result)  # <map object 어쩌구저쩌구>
print(list(result))  # ['1', '2', '3']
#전체 값을 확인하려면 list나 tuple로 형변환을 해주거나 반복을 돌려야 한다.
```
6. **lambda 표현식**
```
def addition(x, y):
    return x + y

result = addition(3, 5)
print(result)   # 8

# lambda 사용하면
addition = lambda x, y: x + y

result = addition(3, 5)
print(result)   # 8

#람다 표현식 활용
numbers = [1, 2, 3, 4, 5]

# lambda 미사용
def square(x):
    return x**2

squared1 = list(map(square, numbers))
print(squeared1)   # [1, 4, 9, 16, 25]


# lambda 사용
squared2 = list(map(lambda x: x**2, numbers))
print(squeared2)   # [1, 4, 9, 16, 25]
```
7. **zip 함수**
```
girls = ['jane', 'ashley']
boys = ['peter', 'jay']
pair = zip(girsl, boys)

print(pair)  # <zip object 어쩌구저쩌구>
print(list(pair))  # [('jane', 'peter'), ('ashley', 'jay')]
```

### 라이브러리
라이브러리 > 패키지 > 모듈
- 연관 모듈들을 하나의 디렉토리에 모아놓은 것 = 패키지
  
1. **내장 모듈 가져올 때**
```
#import만 사용
import math

print(math.pi)       #모듈명.변수명
print(math.sqrt(4))  #모듈명.함수명

#from 절 사용

from math import pi, sqrt

print(pi)        #변수명
print(sqrt(4))   #함수명

# 별칭 부여(as)
import pandas as pd
import matplotlib.pyplot as plt

plt.plot(x, y)
#긴 함수나 변수명에 별칭 부여해서 간단하게 사용
```

2. **사용자 정의 모듈** (직접 정의한 모듈 사용)  
```
# my_math.py 생성하여 두 수의 합을 구하는 add 함수 작성
def add(x,y):
    return x + y

# 같은 위치에 sample.py 파일을 생성하고 my_math 모듈의 add 함수 import 후 add 함수 호출
import my_math

print(my_math.add(10, 20)) # 30
```
3. **외부 패키지 설치하여 사용할 때**
```
# requests 패키지 예시
pip install requests # 설치할 파일 위치에서 터미널에 입력

import requests

url = '내가 요청할 url'
response = requests.get(url).json()
print(response)

# .get(url) 주어진 url로 요청하는 requests 패키지 메서드
# .json() 문자열로 이루어진 json 자료형을 dict 자료형으로 변환시키는 requests 패키지 메서드
```

### 제어문
1. **조건문**
```
temp = int(input())  # input 받는 것은 문자열로 저장되기 때문에 정수형으로 변경

if temp > 30:            # 만약 입력이 30을 초과하면
    print('so hot')      

elif temp > 25:          # 아래는 실행되지 않는다.
    print('hot')

else:
    print('soso')

---
if temp > 30:            # 만약 입력이 30을 초과해도
    print('so hot')

if tmep >25:             # 실행된다. (위의 if와 별개의 if 문으로 인식)
    print('hot')

else:
    print('soso')

---
if temp > 30:
    print('so hot')

    print('bye')         # if가 True일 때 같이 실행됨, 들여쓰기 유의

print('good bye')        # if 문이 종료되면 출력됨
```

2. **중첩 조건문**
```
temp = 36   # 출력: so hot
            #      dangerous

if temp > 30:            
    print('so hot')

    if temp > 35:
        print('dangerous')     

elif temp > 25:          
    print('hot')

else:
    print('soso')
```
  
3. **반복문**
- for 문
```
item_list = ['apple', 'banana', 'coconut']

for item in itme_list:   # item : 반복 변수
    print(item)

# 출력
"""
apple
banana
coconut
"""

country = 'Korea'

for char in country:
    print(char)

# 출력
"""
K
o
r
e
a
"""

for i in range(5):
    print(i)

# 출력
"""
0
1
2
3
4
"""

my_dict = {
    'x': 10,
    'y': 20,
    'z': 30,
}

for key in my_dict:
    print(key)
    print(my_dict[key])

# 출력
"""
x
10 
y
20
z
30
"""
# 딕셔너리 반복의 임시변수는 key다.
# value를 출력하려면 print(my_dict)로 해야 한다.

numbers = [4, 6, 10, -8, 5]

for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2

print(numbers)     # [8, 12, 20, -16, 10]
```

- 중첩되었을 때 for 문
```
outers = ['A', 'B']
inners = ['c', 'd']

for outer in outers:
    for inner in inners:
        print(outer, inner)

# 출력
(A, c)
(A, d)
(B, c)
(B, d)

# 중첩되었을 때 바깥 반복문의 한 번 돌 때, 안 반복문이 다 돌아야 한다.
# 안 반복문이 다 돌고난 후 바깥 반복문의 다음 번 순서가 돌아간다.

elements = [['A', 'B'], ['c', 'd']]

for elem in elemnets:
    for item in elem:
        print(item)

#출력
"""
A
B
C
D
"""
```
- while 문 : 반드시 종료 조건 필요
```
while a < 3:   # 종료 조건
    print(a)
    a += 1

print('end')

# 출력
"""
0
1
2
끝
"""

account = 100

if account > 0:       #결과가 참일 때 진행
    account -= 50

while account > 0:    #결과가 참인 동안 진행
     account -= 50    #언젠가 조건이 False가 되게끔 만들어야 함

#위 코드에서 구조적으로는 if와 while은 같은 결과가 나오긴함

account = 100

while account > 0:
    account += account * 0.035   #위험!! 전역변수 값에 따라 무한 반복됨
    account -= 50

#만약 account가 10000이었다면 무한반복이 되었을 것임.
#350 증가하는데 50씩만 감소하기때문에
```
  
- 반복 제어
```
for i in range(10):
    if i == 5:
        break     # break 만나면 남은 코드 무시하고 반복 즉시 종료
    print(i)      # 0 1 2 3 4

    if i % 2 == 0:
        continue  # continue 만나면 다음 코드는 무시하고 다음 반복을 수행
    print(i)      # 1 3 5 7 9

while True:
    if condition1:
        break
    elif condition2:
        pass         # 빈 코드를 의미
    else:
        print('출력')


# for-else 예시

registered_ids = ['user1', 'user2', 'user3']
id_to_check = 'user1'

for existing_id in registered_ids:
    if existing_id == id_to_check:
        print('이미 사용 중인 아이디입니다.')
        break
else:     #for 루프가 break로 중단되면 실행됨
    print('사용 가능한 아이디입니다.')

```
